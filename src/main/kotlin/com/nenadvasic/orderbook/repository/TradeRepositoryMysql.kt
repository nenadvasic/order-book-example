package com.nenadvasic.orderbook.repository

import com.nenadvasic.orderbook.model.enums.Side
import com.nenadvasic.orderbook.model.Trade
import kotlinx.datetime.toJavaInstant
import org.jetbrains.exposed.dao.IntEntity
import org.jetbrains.exposed.dao.IntEntityClass
import org.jetbrains.exposed.dao.id.EntityID
import org.jetbrains.exposed.dao.id.IntIdTable
import org.jetbrains.exposed.sql.Column
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.javatime.timestamp
import org.jetbrains.exposed.sql.transactions.transaction
import java.math.BigDecimal
import java.time.Instant

class TradeRepositoryMysql(private val database: Database) : TradeRepository {

    // Exposed DB table object
    object TradeTable : IntIdTable("trades") {
        // Note: time column is Java Instant, but we use Kotlin Instant in the rest of the app
        val time: Column<Instant> = timestamp("time")
        val price: Column<BigDecimal> = decimal("price", 16, 4)
        val amount: Column<BigDecimal> = decimal("amount", 16, 4)
        val side =
            customEnumeration(
                "side", "ENUM('BUY','SELL')",
                { value -> Side.valueOf(value as String) },
                { it.name }
            )
    }

    // Exposed DB row
    class TradeRow(id: EntityID<Int>) : IntEntity(id) {
        companion object : IntEntityClass<TradeRow>(TradeTable)

        var time by TradeTable.time
        var price by TradeTable.price
        var amount by TradeTable.amount
        var side by TradeTable.side
    }

    private fun TradeRow.toModel(): Trade {
        return Trade(
            id = id.value,
            time = kotlinx.datetime.Instant.parse(time.toString()),
            price = price.stripTrailingZeros(),
            amount = amount.stripTrailingZeros(),
            side = side,
        )
    }

    override fun saveTrade(trade: Trade): Trade {
        return transaction(database) {
            // if trade.id is null than row id will be generated by db auto increment
            TradeRow.new(trade.id) {
                time = trade.time.toJavaInstant()
                price = trade.price
                amount = trade.amount
                side = trade.side
            }.toModel()
        }
    }

    override fun getAllTrades(): List<Trade> {
        return transaction(database) {
            TradeRow.all().sortedByDescending { it.id }.map { it.toModel() }
        }
    }

    override fun getLastTrade(): Trade? {
        return transaction(database) {
            // TODO Find a better way instead of calling .all()
            TradeRow.all().sortedByDescending { it.id }.map { it.toModel() }.getOrNull(0)
        }
    }
}
