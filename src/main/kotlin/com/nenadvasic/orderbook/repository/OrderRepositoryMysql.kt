package com.nenadvasic.orderbook.repository

import com.nenadvasic.orderbook.model.Order
import com.nenadvasic.orderbook.model.enums.Side
import kotlinx.datetime.toJavaInstant
import org.jetbrains.exposed.dao.IntEntity
import org.jetbrains.exposed.dao.IntEntityClass
import org.jetbrains.exposed.dao.id.EntityID
import org.jetbrains.exposed.dao.id.IntIdTable
import org.jetbrains.exposed.sql.Column
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.and
import org.jetbrains.exposed.sql.javatime.timestamp
import org.jetbrains.exposed.sql.transactions.transaction
import java.math.BigDecimal
import java.time.Instant

class OrderRepositoryMysql(private val database: Database) : OrderRepository {

    // Exposed DB table object
    object OrderTable : IntIdTable("orders") {
        // Note: time column is Java Instant, but we use Kotlin Instant in the rest of the app
        val time: Column<Instant> = timestamp("time")
        val price: Column<BigDecimal> = decimal("price", 16, 4)
        val amount: Column<BigDecimal> = decimal("amount", 16, 4)
        val filledAmount: Column<BigDecimal> = decimal("filled_amount", 16, 4)
        val side =
            customEnumeration(
                "side", "ENUM('BUY','SELL')",
                { value -> Side.valueOf(value as String) },
                { it.name }
            )
        val active: Column<Boolean> = bool("active")
    }

    // Exposed DB row
    class OrderRow(id: EntityID<Int>) : IntEntity(id) {
        companion object : IntEntityClass<OrderRow>(OrderTable)

        var time by OrderTable.time
        var price by OrderTable.price
        var amount by OrderTable.amount
        var filledAmount by OrderTable.filledAmount
        var side by OrderTable.side
        var active by OrderTable.active
    }

    private fun OrderRow.toModel(): Order {
        return Order(
            id = id.value,
            time = kotlinx.datetime.Instant.parse(time.toString()),
            price = price.stripTrailingZeros(),
            amount = amount.stripTrailingZeros(),
            filledAmount = filledAmount.stripTrailingZeros(),
            side = side,
            active = active
        )
    }

    override fun saveOrder(order: Order): Order {
        return transaction(database) {
            // if order.id is null than row id will be generated by db auto increment
            OrderRow.new(order.id) {
                time = order.time.toJavaInstant()
                price = order.price
                amount = order.amount
                filledAmount = order.filledAmount
                side = order.side
                active = order.active
            }.toModel()
        }
    }

    override fun getAllActiveOrders(): List<Order> {
        return transaction(database) {
            OrderRow.find { OrderTable.active eq true }.map { it.toModel() }
        }
    }

    override fun getOppositeBuyingOrders(sellingOrderPrice: BigDecimal): List<Order> {
        return transaction(database) {
            OrderRow
                .find {
                    OrderTable.active eq true and
                            (OrderTable.price greaterEq sellingOrderPrice) and
                            (OrderTable.side eq Side.BUY)
                }
                .sortedByDescending { it.price }
                .sortedBy { it.time }
                .map { it.toModel() }
        }
    }

    override fun getOppositeSellingOrders(buyingOrderPrice: BigDecimal): List<Order> {
        return transaction(database) {
            OrderRow
                .find {
                    OrderTable.active eq true and
                            (OrderTable.price lessEq buyingOrderPrice) and
                            (OrderTable.side eq Side.SELL)
                }
                .sortedBy { it.price }
                .sortedBy { it.time }
                .map { it.toModel() }
        }
    }

    override fun decreaseAmount(orderId: Int, amountToDecrease: BigDecimal): Order {
        return transaction(database) {
            val orderRow = OrderRow.findById(orderId) ?: throw IllegalArgumentException("Order not found for given id")

            if (amountToDecrease > orderRow.amount) {
                throw IllegalArgumentException("The amount to decrease can not be greater than existing amount")
            }

            orderRow.amount -= amountToDecrease
            orderRow.filledAmount += amountToDecrease

            if (orderRow.amount.compareTo(BigDecimal.ZERO) == 0) {
                orderRow.active = false
            }

            orderRow
        }.toModel()
    }

    override fun setActiveToFalse(orderId: Int): Order {
        return transaction(database) {
            val orderRow = OrderRow.findById(orderId) ?: throw IllegalArgumentException("Order not found for given id")

            orderRow.active = false
            orderRow
        }.toModel()
    }
}
